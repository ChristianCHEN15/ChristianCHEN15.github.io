<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java8函数式编程</title>
      <link href="/2024/09/03/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/09/03/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">**什么是函数式编程?**</span><br><span class="line"></span><br><span class="line">百度百科： 函数式编程，是一种编程范式，它将电脑运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算为该语言最重要的基础。而且，λ演算的函数可以接受函数作为输入参数和输出返回值。</span><br><span class="line"></span><br><span class="line">讲人话： 函数式编程一种编程范式,允许使用一种表达式（lambda表达式）来表示一个函数</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数式接口</span></span><br><span class="line"></span><br><span class="line">&gt; Java语言中函数式编程，通过Java8版本提供的`函数式接口规范`来实现,它指的是有且只有一个未实现的方法的接口，一般通过`FunctionalInterface`这个注解来表明某个接口是一个函数式接口(非必须，如果标注了该注解，编译器检查接口是否符合函数式接口规范，如出现两个及以上数量的普通方法，编译器会报错)。函数式接口是Java支持函数式编程的基础。java8及以上版本才支持。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 入门</span></span><br><span class="line"></span><br><span class="line">使用Consumer作为示例，它是一个函数式接口，包含一个抽象方法accept，这个方法只有输入而无输出。</span><br><span class="line">现在我们要定义一个Consumer对象，传统的方式是这样定义的：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">Consumer c = new <span class="function"><span class="title">Consumer</span></span>() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Object o) &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而在Java8中，针对函数式编程接口，可以这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> (o) -&gt; &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>上面已说明，函数式编程接口都只有一个抽象方法，因此在采用这种写法时，编译器会将这段函数编译后当作该抽象方法的实现。<br>如果接口有多个抽象方法，编译器就不知道这段函数应该是实现哪个方法的了。<br>因此，&#x3D;后面的函数体我们就可以看成是accept函数的实现。</p><ul><li>输入：-&gt;前面的部分，即被()包围的部分。此处只有一个输入参数，实际上输入是可以有多个的，如两个参数时写法：(a, b);当然也可以没有输入，此时直接就可以是()</li><li>函数体：-&gt;后面的部分，即被{}包围的部分；可以是一段代码。</li><li>输出：函数式编程可以没有返回值，也可以有返回值。如果有返回值时，需要代码段的最后一句通过return的方式返回对应的值</li></ul><p>当函数体中只有一个语句时，可以去掉{}进一步简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> (o) -&gt; System.out.println(o);</span><br></pre></td></tr></table></figure><p>然而这还不是最简的，由于此处只是进行打印，调用了System.out中的println静态方法对输入参数直接进行打印，因此可以简化成以下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Consumer</span> <span class="variable">c</span> <span class="operator">=</span> System.out::println;</span><br></pre></td></tr></table></figure><p>它表示的意思就是针对输入的参数将其调用System.out中的静态方法println进行打印。<br>到这一步就可以感受到函数式编程的强大能力。<br>通过最后一段代码，我们可以简单的理解函数式编程，Consumer接口直接就可以当成一个函数了，这个函数接收一个输入参数，然后针对这个输入进行处理；当然其本质上仍旧是一个对象，但我们已经省去了诸如老方式中的对象定义过程，直接使用一段代码来给函数式接口对象赋值。<br>而且最为关键的是，这个函数式对象因为本质上仍旧是一个对象，因此可以做为其它方法的参数或者返回值，可以与原有的代码实现无缝集成！</p><h2 id="Java预设函数式接口"><a href="#Java预设函数式接口" class="headerlink" title="Java预设函数式接口"></a>Java预设函数式接口</h2><blockquote><p>下面对Java中的几个预先定义的函数式接口及其经常使用的类进行分析学习。在 <code>java.util.function</code>包下提供了很多函数式接口，这里挑几个常用的进行讲解。</p></blockquote><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>Consumer是一个函数式编程接口； 顾名思义，Consumer的意思就是消费，即针对某个东西我们来使用它，因此它包含有一个有输入而无输出的accept接口方法；<br>除accept方法，它还包含有andThen这个方法；<br>其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这个方法就是指定在调用当前Consumer后是否还要调用其它的Consumer；<br>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consumerTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">f</span> <span class="operator">=</span> System.out::println;</span><br><span class="line">    <span class="type">Consumer</span> <span class="variable">f2</span> <span class="operator">=</span> n -&gt; System.out.println(n + <span class="string">&quot;-F2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行完F后再执行F2的Accept方法</span></span><br><span class="line">    f.andThen(f2).accept(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连续执行F的Accept方法</span></span><br><span class="line">    f.andThen(f).andThen(f).andThen(f).accept(<span class="string">&quot;test1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p>Function也是一个函数式编程接口；它代表的含义是“函数”，而函数经常是有输入输出的，因此它含有一个apply方法，包含一个输入与一个输出；<br>除apply方法外，它还有compose与andThen及indentity三个方法，其使用见下述示例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">functionTest</span><span class="params">()</span> &#123;</span><br><span class="line">    Function&lt;Integer, Integer&gt; f = s -&gt; s++;</span><br><span class="line">    Function&lt;Integer, Integer&gt; g = s -&gt; s * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面表示在执行F时，先执行G，并且执行F时使用G的输出当作输入。</span></span><br><span class="line"><span class="comment">     * 相当于以下代码：</span></span><br><span class="line"><span class="comment">     * Integer a = g.apply(1);</span></span><br><span class="line"><span class="comment">     * System.out.println(f.apply(a));</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(f.compose(g).apply(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示执行F的Apply后使用其返回的值当作输入再执行G的Apply；</span></span><br><span class="line"><span class="comment">     * 相当于以下代码</span></span><br><span class="line"><span class="comment">     * Integer a = f.apply(1);</span></span><br><span class="line"><span class="comment">     * System.out.println(g.apply(a));</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(f.andThen(g).apply(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * identity方法会返回一个不进行任何处理的Function，即输出与输入值相等； </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(Function.identity().apply(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p>Predicate为函数式接口，predicate的中文意思是“断定”，即判断的意思，判断某个东西是否满足某种条件； 因此它包含test方法，根据输入值来做逻辑判断，其结果为True或者False。<br>它的使用方法示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Predicate测试</span><br><span class="line"> */</span><br><span class="line">private static void predicateTest() &#123;</span><br><span class="line">    Predicate&lt;String&gt; p = o -&gt; o.equals(&quot;test&quot;);</span><br><span class="line">    Predicate&lt;String&gt; g = o -&gt; o.startsWith(&quot;t&quot;);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * negate: 用于对原来的Predicate做取反处理；</span><br><span class="line">     * 如当调用p.test(&quot;test&quot;)为True时，调用p.negate().test(&quot;test&quot;)就会是False；</span><br><span class="line">     */</span><br><span class="line">    Assert.assertFalse(p.negate().test(&quot;test&quot;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * and: 针对同一输入值，多个Predicate均返回True时返回True，否则返回False；</span><br><span class="line">     */</span><br><span class="line">    Assert.assertTrue(p.and(g).test(&quot;test&quot;));</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * or: 针对同一输入值，多个Predicate只要有一个返回True则返回True，否则返回False</span><br><span class="line">     */</span><br><span class="line">    Assert.assertTrue(p.or(g).test(&quot;ta&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><blockquote><p>Stream可以对多个元素进行一系列的操作，也可以支持对某些操作进行并发处理。Java8中对集合、数组进行了stream的实现，方便开发人员通过stream对集合或数组进行数据操作。</p></blockquote><h2 id="Stream对象的创建"><a href="#Stream对象的创建" class="headerlink" title="Stream对象的创建"></a>Stream对象的创建</h2><p>Stream对象的创建途径有以下几种</p><p>a. 创建空的Stream对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stream</span> <span class="variable">stream</span> <span class="operator">=</span> Stream.empty();</span><br></pre></td></tr></table></figure><p>b. 通过集合类中的stream或者parallelStream方法创建；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Arrays.stream(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>&#125;);</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line"><span class="type">Stream</span> <span class="variable">listStream</span> <span class="operator">=</span> list.stream();                   <span class="comment">//获取串行的Stream对象</span></span><br><span class="line"><span class="type">Stream</span> <span class="variable">parallelListStream</span> <span class="operator">=</span> list.parallelStream();   <span class="comment">//获取并行的Stream对象  </span></span><br></pre></td></tr></table></figure><p>c. 通过Stream中的of方法创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream s = Stream.of(&quot;test&quot;);</span><br><span class="line">Stream s1 = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span><br></pre></td></tr></table></figure><p>d. 通过Stream中的iterate方法创建：<br>iterate方法有两个不同参数的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(T seed, Predicate&lt;? <span class="built_in">super</span> T&gt; hasNext, UnaryOperator&lt;T&gt; next)</span></span><br></pre></td></tr></table></figure><p>其中第一个方法将会返回一个无限有序值的Stream对象：它的第一个元素是seed，第二个元素是f.apply(seed); 第N个元素是f.apply(n-1个元素的值)；生成无限值的方法实际上与Stream的中间方法类似，在遇到中止方法前一般是不真正的执行的。因此无限值的这个方法一般与limit等方法一起使用，来获取前多少个元素。<br>当然获取前多少个元素也可以使用第二个方法。<br>第二个方法与第一个方法生成元素的方式类似，不同的是它返回的是一个有限值的Stream；中止条件是由hasNext来断定的。</p><p>第二种方法的使用示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 本示例表示从1开始组装一个序列，第一个是1，第二个是1+1即2，第三个是2+1即3..，直接10时中止；</span><br><span class="line"> * 也可简化成以下形式：</span><br><span class="line"> *        Stream.iterate(1,</span><br><span class="line"> *        n -&gt; n &lt;= 10,</span><br><span class="line"> *        n -&gt; n+1).forEach(System.out::println);</span><br><span class="line"> * 写成以下方式是为简化理解</span><br><span class="line"> */</span><br><span class="line">Stream.iterate(1,</span><br><span class="line">        new Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean test(Integer integer) &#123;</span><br><span class="line">                return integer &lt;= 10;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    new UnaryOperator&lt;Integer&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Integer apply(Integer integer) &#123;</span><br><span class="line">            return integer+1;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>e. 通过Stream中的generate方法创建<br>与iterate中创建无限元素的Stream类似，不过它的每个元素与前一元素无关，且生成的是一个无序的队列。也就是说每一个元素都可以随机生成。因此一般用来创建常量的Stream以及随机的Stream等。<br>示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 随机生成10个Double元素的Stream并将其打印</span><br><span class="line"> */</span><br><span class="line">Stream.generate(new Supplier&lt;Double&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Double get() &#123;</span><br><span class="line">        return Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).limit(10).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">//上述写法可以简化成以下写法：</span><br><span class="line">Stream.generate(() -&gt; Math.random()).limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h2 id="Stream对象的使用"><a href="#Stream对象的使用" class="headerlink" title="Stream对象的使用"></a>Stream对象的使用</h2><p>Stream对象提供多个非常有用的方法，这些方法可以分成两类：<br>中间操作：将原始的Stream转换成另外一个Stream；如filter返回的是过滤后的Stream。<br>终端操作：产生的是一个结果或者其它的复合操作；如count或者forEach操作。</p><p>下面就几个比较常用的方法举例说明其用法：</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>用于对Stream中的元素进行过滤，返回一个过滤后的Stream<br>其方法定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(&quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;, &quot;aaaa&quot;);</span><br><span class="line">//查找所有包含t的元素并进行打印</span><br><span class="line">s.filter(n -&gt; n.contains(&quot;t&quot;)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>元素一对一转换。<br>它接收一个Funcation参数，用其对Stream中的所有元素进行处理，返回的Stream对象中的元素为Function对原元素处理后的结果<br>其方法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);</span><br></pre></td></tr></table></figure><p>示例，假设我们要将一个String类型的Stream对象中的每个元素添加相同的后缀.txt，如a变成a.txt，其写法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(&quot;test&quot;, &quot;t1&quot;, &quot;t2&quot;, &quot;teeeee&quot;, &quot;aaaa&quot;);</span><br><span class="line">s.map(n -&gt; n.concat(&quot;.txt&quot;)).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>元素一对多转换：对原Stream中的所有元素使用传入的Function进行处理，每个元素经过处理后生成一个多个元素的Stream对象，然后将返回的所有Stream对象中的所有元素组合成一个统一的Stream并返回；<br>方法定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);</span><br></pre></td></tr></table></figure><p>示例，假设要对一个String类型的Stream进行处理，将每一个元素的拆分成单个字母，并打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = Stream.of(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;t1&quot;</span>, <span class="string">&quot;t2&quot;</span>, <span class="string">&quot;teeeee&quot;</span>, <span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">s.flatMap(n -&gt; Stream.of(n.split(<span class="string">&quot;&quot;</span>))).forEach(System.out::println);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> java8 </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国各省人湖北人、湖南人、广东人、河南人</title>
      <link href="/2024/08/28/%E4%B8%AD%E5%9B%BD%E5%90%84%E7%9C%81%E4%BA%BA%E6%B9%96%E5%8C%97%E4%BA%BA%E3%80%81%E6%B9%96%E5%8D%97%E4%BA%BA%E3%80%81%E5%B9%BF%E4%B8%9C%E4%BA%BA%E3%80%81%E6%B2%B3%E5%8D%97%E4%BA%BA/"/>
      <url>/2024/08/28/%E4%B8%AD%E5%9B%BD%E5%90%84%E7%9C%81%E4%BA%BA%E6%B9%96%E5%8C%97%E4%BA%BA%E3%80%81%E6%B9%96%E5%8D%97%E4%BA%BA%E3%80%81%E5%B9%BF%E4%B8%9C%E4%BA%BA%E3%80%81%E6%B2%B3%E5%8D%97%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、-河南人"><a href="#一、-河南人" class="headerlink" title="一、 河南人"></a>一、 河南人</h1><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2020/0530/b7bce8a4j00qb4nh2002jc000i200d3c.jpg&thumbnail=660x2147483647&quality=80&type=jpg"></p><p>河南是中华民族的发祥地，六大古都有三个在河南。不过现在在全国名声最糟，北京上海、广州、深圳这些大城市的公司，都不愿意雇佣河南人，有”防火防盗防河南人”之说，甚至在深圳打出了</p><p>“严厉打击河南籍犯罪团伙”的条幅。大概是地狭窄人多（快一亿了），竞争激烈，很多人似乎天生就很狡黠，爱耍小聪明。河南的公司信誉很糟糕，能骗则骗，能坑则坑，与他们做生意很冒险。郑州、新乡、安阳集中了很多骗子公司，以委托加工、加盟的方式诈骗，当地政府根本不管。</p><p>河南人在大城市里普遍地位不高，但名声却最”响亮”<br>，收废品的很多（常常顺手牵羊），固始县是”废品之乡”<br>。做小姐的也不少，更多的游荡于城市之间。在北京的犯罪率仅次于东北人（东北人打架，河南人盗窃、诈骗更招人恨）。大概是朝中无人，形象又不佳，所以没有话语权，处处受排挤，甚至很多河南人都改称是河北人、山东人。</p><p>其实很多河南人，尤其是农村人是很朴实的，很勤奋，能吃苦，生活习惯历来以简朴著称。乡土观念很重，但也墨守成规，不思进取，封闭保守，是中国第一大劳动力省。河南人在家很讲究礼仪，无论日常相见、迎送、借还、庆吊、生育、成年、婚嫁、寿诞、丧葬等，都很注重礼节和仪表。不过河南人衣着邋遢、不爱洗澡是出了名的。近些年很多在外的河南人胡作非为，糟蹋了一个省的名声。尽管政府竭力在改变形象，可是坏名声已经根深蒂固。而很多人对河南人的过度责骂，则已数典忘祖了：客家人、甚至上海人的祖先也是河南人。</p><h1 id="二、湖北人"><a href="#二、湖北人" class="headerlink" title="二、湖北人"></a>二、湖北人</h1><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2020/0530/84b47cc7j00qb4nh2001ec000g400ajc.jpg&thumbnail=660x2147483647&quality=80&type=jpg"></p><p>毗邻河南，”天上九头鸟，地下湖北佬<br>“，狡猾善变，汉正街的假货也曾威震华中。不过湖北人名声没有河南人那么糟糕。湖北号称”千湖之省<br>“，水多自然有灵性，故美女也不少。湖北人很聪明，高考竞争激烈，高分者甚多，湖北人很善于读书，著名的黄冈中学名噪全国，甚至连北京上海的重点中学都自愧不如，湖北人在大学里很多都是佼佼者。天门是内地著名的侨乡，仙桃、潜江也很富裕，堪比沿海地区。可是与安徽、河南交界的大别山区的红安、麻城、英山却是全国最穷的地区之一，那里的人也比较凶狠好斗。鄂西的恩施、十堰、老河口也比较穷。红安是最著名的<br>“将军县”（出了 233 个将军），大概是时势造英雄吧，在那个年代，只要很穷、身体好、胆子大、命大必有后福。湖北人性格张扬刚烈，，但不如四川人凶狠。农村人比较实在，湖北也是民工大省。</p><h1 id="三、湖南人"><a href="#三、湖南人" class="headerlink" title="三、湖南人"></a>三、湖南人</h1><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2020/0530/782d598cj00qb4nh300a8c0015o01bnc.jpg&thumbnail=660x2147483647&quality=80&type=jpg"></p><p>湖南人号称<br>“中国的伟人之都”，性格内敛，韬光养晦，有时又象辣椒一样火暴，精明强干。史书上最多的赞誉之辞都给了湖南人：<br>“惟楚有材，于斯为盛”（岳麓书院）、” 楚虽三户能亡秦”、”无湘不成军 “、”湘人不倒，华夏不倾”、<br>“天下不可一日无湖南”，“湖广熟，天下足”。曾国藩、左宗棠的湘军把大清朝的香火延续了将近半个世纪，共产党的开国元勋也有很多来自湖南，可以说中国近代史和半部中国现代史都是湖南人用鲜血和生命写就的。湖南人聪明勇敢，刚烈果决，敢任大事，以天下兴亡为己任，”若道中华国果亡，除非湖南人死光”，湖南人集中了中华民族的优秀美德，读书、当兵打仗、做劳力都不错。不过近些年却有世风日下之势，长沙是个典型的消费城市，洗浴城遍地都是（里面都有小姐），消费一点也不低，很多当地人没钱也洗，广东人也过来凑热闹；双峰是中国的”</p><p>假证之乡”，辐射全国，从业人员有十万之多；据说桃江的美女不错；邵阳盛产黑社会，恶性犯罪不断；郴州出贪官；湘潭人生活节奏很慢，很多人嚼着槟榔悠哉悠哉（湖南不产槟榔，却比海南人嚼的还多，该物容易上瘾，严重致癌）。湖南人有三气：灵气、匪气和霸气，一旦成了暴力团伙，危害极大，广东严打的”飞车党”不少是湖南人，<br>“湖南帮”仅次于 “东北帮”和”河南帮 “，广东本地的犯罪团伙反而不多。湖南盛产美女，精干聪慧，做事麻利，素有”湘女多情<br>“之说，但做老婆不太可靠，从事服务行业的人数与川妹、东北妹齐名。</p><h1 id="四、广东人"><a href="#四、广东人" class="headerlink" title="四、广东人"></a>四、广东人</h1><p><img src="https://nimg.ws.126.net/?url=http://dingyue.ws.126.net/2020/0530/cabc6c00j00qb4nh3002tc000u000mic.jpg&thumbnail=660x2147483647&quality=80&type=jpg"></p><p>广东人是中国人中最复杂的一群，其身材多矮小，颧骨突出，目小深陷，鼻扁阔，唇厚而翻。主要有三大方言：白话，潮汕话，客家话。历史上广东就是一个百越杂处地区，沿海还有东南亚人进入，称为广府人，包括港澳；潮汕地区的人也有着独特的语言和风俗。这两者都属于土著广东人，从生物学角度来讲，与北方的人种起源是不同的。”五胡乱华”<br>以后，中原地区（主要是河南）的汉人大量南迁，聚居在今天的梅州、河源和揭阳、汕尾的部分地区，讲客家话。这部分汉人应该算是血统最”纯种<br>“的汉人了，有一千多万，孙中山、李嘉诚也是客家人。历史上广东人在西方传教士描述中的形象十分糟糕：身材瘦小、形象猥琐、狡诈、肮脏、嗜赌、内讧，懦弱，食婴。广东人是最早在海外谋生的中国人，华侨有两千多万，长期代表着中国人的形象，潮汕人同温州人一样在国外以经商闻名。由于对广东人的妖魔化宣传，美国、加拿大持续了半个世纪的”排华”运动。广东是近代民主革命的发源地，东西方文明的交汇点，改革开放的桥头堡和排头兵；广东人是海洋的族群，充满朝气与活力，头脑灵活，富于冒险性、开创性，敢为天下先，广东人对空头理论不感兴趣，也没有工夫空谈哲理、人生，对政治也不感兴趣。人人都为了钱忙忙碌碌，整日东奔西跑。北方人是先思考后行动，而广东人是先行动后思考，看重的是效益和价值，不注重形式和外表。广东现在已成为中国经济最发达的地区。广东的男人朴实憨厚，吃苦耐劳，广东女人很勤劳贤惠，每个人都能煲手好汤，做手好菜。可是现在对广东人的人文形象却是贬多褒少。最常见的评价就是：</p><p>1、冷漠、排外、自大。广州是个花花世界，中国最冷漠的城市，如果是一对一的问路尤其是外乡话，很少会搭理你。邻里之间，关门闭户，互不搭理，多一事不如少一事。</p><p>2、广东人有茶文化、酒文化、食蛇文化、喝汤文化多的是，却不爱接受国粹，只崇拜港台文化，只有港台的娱乐名人，才是心中的偶像。只有白话口水歌，才能最打动他们。广东人爱看港澳台。经济与文化并没有齐头并进。</p><p>3、部分广东人没素质。一些男女，大白天穿着睡衣，逛街走巷去超市旁若无人。</p><p>4、嗜赌成性，体彩、福彩销售火暴。不是甘于奉献，否则六合彩、赌球也不会一样火暴。</p><p>5、广东人最迷信，喜欢弄一些阴阳鬼气的东西辟邪。南海神庙会、菠萝庙会一年好几次。逢年过节都爱在自己家里做道场，香火不断。车牌号、门牌号、电话号、婚嫁日期、开业日期都择<br>“6”和” 8”。更有甚者，连生孩子也择日期作剖腹产。每年的”9.18”国耻日”竟然是广东人的良辰吉日。有的祖坟修的比住宅都豪华（恐怕不全是孝顺）。</p><p>6、广东帅哥靓女实在太少，街头遇到的美女都是四川、湖南的。广东女人很无奈，没了男人就没了生活的自信，只会息事宁人，一个人默然地哀泣，从来都不会用法律来保卫自己。</p><p>7、广东人什么都敢吃，蛇、老鼠、狗、猫、蛆、禾花雀、禾虫、穿山甲、婴儿以及各类野生保护类动物，直到最后吃出果子狸。1949 年解放军南下，当时准备两广战役的是东北战士，听到这类恶习仗都不想打了，准备撤回衡阳！</p><p>8、广东人造假碟、假钱、假药泛滥全国，给食品加有害的色素（潮州是著名的干果之乡，很多作坊的工人都带着防毒面具），广东的城市治安都很差，广州、深圳、东莞是最没有安全感的城市（当然不能都怪广东人，大部分是外省人所为）。汕头是最失败的特区，楼房破旧，街道坎坷，潮阳一带的人很不开化（有很多制假币、制毒的窝点）。可笑的是汕头人很喜欢把政府、企业、门店的招牌写成繁体字，深圳的外资经济比汕头发达 N 倍，也没见用繁体字。东莞又脏又乱，包括运河，臭气熏天，最可怕的是大白天劫匪横行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/08/26/hello-world/"/>
      <url>/2024/08/26/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
